# Потоковый арбитр с политикой Quolity-of-Service (QoS)
======
## 1. Проектирование

  *Первым делом при проектировании арбитра следует реализовать модуль, решающий задачу приоритетности  
  *Второй этап заключается в реализации конечного автомата  
  *Заключительный этап сводится к реализации регистровых передач и прочей комбинационной логики  

  Микроархитектурная диаграмма модуля stream_arbiter:

  ![Микроархитектурная диаграмма stream_arbiter](https://github.com/Nealan22/task/blob/master/stream_arbiter.drawio.png "Микроархитектурная диаграмма stream_arbiter")

  Описание работы спроектированных модулей:

  *Модуль приоритетности prior  
    Идея заключается в сравнении значений s_qos_i входных потоков и вывода значения qos_i. 
    Возможны четыре варианта:
    1. qos_i принимает значение 2'b11 при:
    - одновременном обращении двух потоков (s_valid_i[0] & s_valid[1]) и совпадении s_qos_i;
    - одновременном обращении двух потоков (s_valid_i[0] & s_valid[1]) и приоритете одного из потоков s_qos_i = 0.  
    2. qos_i принимает значение равное 2'b01 при:
    - обращении на передачу только нулевого потока;
    - одновременном обращении на передачу двух потоков в случае, когда s_qos_i[0] > s_qos_i[1] и s_qos_i[1] != 0.  
    3. qos_i принимает значение равное 2'b10 при:
    - обращении на передачу только первого потока;
    - одновременном обращении на передачу двух потоков в случае, когда s_qos_i[1] > s_qos_i[0] и s_qos_i[0] != 0.
    4. qos_i принимает значение равное 2'b00 при:
    - отсутствии запросов;
    - одновременном обращении на передачу двух потоков с нулевыми значениями приоритетов.

  *FSM
    Конечный автомат (КА) состоит из 4-х состояний: IDLE, BCAST, RRBCAST, FRBCAST:
    1. IDLE
    Сигнал сброса устанавливает состояние автомата равное IDLE.
    Состояние, в которое будет осуществлен переход из состояния IDLE, зависит от результата анализа приоритетности входных значений qos_i:
    - если qos_i = 2'b11, то КА переходит в состояние RRBCAST;
    - если qos_i = 2'b01 | qos_i = 2'b10, то КА переходит в состояние BCAST.
    2. BCAST
    Данное состояние подразумевает передачу наиболее приоритетного потока.
    По завершению передачи транзакции КА переходит в состояние ожидания.
    3. RRBCAST
    Исходя из принципа Round-Robin передача обоих потоков должна произойти независимо от того, с каким приоритетом придет следующая транзакция.
    Данное состояние подразумевает передачу нулевого потока.
    По завершению передачи транзакции КА переходит в состояние FRBCAST.
    4. FRBCAST
    Данное состояние подразумевает передачу первого потока.
    При данном состоянии нам не важно наличие более приоритетной транзакции на первом потоке, так как мы следуем принципу Round-Robin. 
    По завершению передачи транзакции КА переходит в состояние ожидания.

  *Register transfer  
    Данный блок отвечает за формирование выходных сигналов в зависимости от состояния КА и значений входных сигналов.

  *Comb other logic  
    Данный блок отвечает за формирование выходных сигналов s_ready_o для оповещения входных потоков о возвомжности передачи данных.

## 2. Кодирование и bring-up тест 

  Тестируемый модуль            - stream_arbiter.sv  
  Тестовое окружение            - stream_arbiter_tb.sv  
  Скрипт для запуска симулятора - stream_arbiter_run_simulation.do  

## 3. Тестовый синтез 

  Для запуска синтеза необходимо открыть проект stream_arbiter.qpf в quartus, а затем запустить Compile design в окне Task.  
  Синтез проводился для fpga EP4CE6E22C7.  
  Все необходимые отчеты находятся в [директории output_files][https://github.com/Nealan22/task/tree/master/output_files].  

  Оптимизация комбинационной логики, а именно уменьшение количества логических элементов модуля prior, позволит увеличить рабочую частоту арбитра.
